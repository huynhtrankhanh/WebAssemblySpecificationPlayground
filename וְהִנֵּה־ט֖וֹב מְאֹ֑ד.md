# SpecTec: Comprehensive Documentation and Reference Guide

## Table of Contents

1. [Introduction](#introduction)
2. [What is SpecTec?](#what-is-spectec)
3. [Getting Started](#getting-started)
4. [Core Concepts](#core-concepts)
5. [Language Reference](#language-reference)
6. [Type System](#type-system)
7. [Expressions](#expressions)
8. [Functions](#functions)
9. [Relations and Rules](#relations-and-rules)
10. [Grammars and Attribute Grammars](#grammars-and-attribute-grammars)
11. [Pattern Matching](#pattern-matching)
12. [Iterations and Sequences](#iterations-and-sequences)
13. [Splicing and Document Generation](#splicing-and-document-generation)
14. [Backends](#backends)
15. [Hints and Customization](#hints-and-customization)
16. [Advanced Features](#advanced-features)
17. [Best Practices](#best-practices)
18. [Examples and Tutorials](#examples-and-tutorials)
19. [Troubleshooting](#troubleshooting)
20. [Internal Representations](#internal-representations)

---

## Introduction

SpecTec is a domain-specific language (DSL) for the formal specification of WebAssembly (Wasm). It serves as a single source of truth that can generate multiple artifacts including LaTeX formal definitions, prose specifications in English, and potentially mechanizations for theorem provers like Coq and Isabelle.

### Why SpecTec?

The WebAssembly specification requires both:
- **Formal specification** - Mathematically rigorous definitions amenable to formal proof
- **Prose specification** - Algorithmic descriptions in stylized English for accessibility

Maintaining these separately is labor-intensive and error-prone. SpecTec solves this by:
- Providing a single, maintainable source of truth
- Automatically generating multiple output formats
- Detecting common specification errors
- Enabling effective code review through clear, diff-able ASCII notation

---

## What is SpecTec?

SpecTec is an **authoring tool** and **DSL** designed to:

1. **Express formal semantics** - Define syntax, typing rules, and operational semantics
2. **Generate artifacts** - Produce LaTeX, prose, and potentially interpreter code
3. **Validate consistency** - Check for type errors, undefined variables, and logical issues
4. **Enable collaboration** - Provide readable, reviewable specifications

### Key Features

- **Declarative syntax** resembling pen-and-paper notation
- **Type checking** for specifications
- **Multiple backends** (LaTeX, Prose, Interpreter)
- **Parameterized types and functions**
- **Pattern matching** for concise definitions
- **Iteration syntax** for sequences and lists
- **Custom notation** with atoms and mixfix operators
- **Attribute grammars** for concrete syntax definition

---

## Getting Started

### Prerequisites

To use SpecTec, you need:

1. **OCaml** (version 5.0.0 or higher)
2. **opam** (version 2.0.5 or higher)
3. **dune** (version 3.11.0)
4. **menhir** (version 20230608)
5. **mdx** (version 2.3.1)
6. **zarith** (version 1.13)

### Installation

```bash
# Install opam
$ apt-get install opam
$ opam init

# Set OCaml version
$ opam switch create 5.0.0

# Install dependencies
$ opam install dune menhir mdx zarith
```

### Building SpecTec

```bash
$ cd spectec
$ make
```

This creates the `spectec` executable.

### Basic Usage

To check a SpecTec file:

```bash
$ spectec myspec.spectec
```

If the specification is well-formed, SpecTec returns silently. Otherwise, it reports errors.

---

## Core Concepts

### Abstract Syntax

SpecTec operates on **abstract syntax**, which describes the syntactic shape of expressions and values. This defines the **syntax types** (the types of the SpecTec language).

### Syntax Types vs Meta-Types

- **Syntax types** - Types describing object-language constructs (e.g., `valtype`, `instr`)
- **Meta-types** - Built-in types for meta-level operations (e.g., `nat`, `bool`, `text`)

### Definitions

SpecTec specifications consist of several kinds of definitions:

1. **Syntax definitions** - Define abstract syntax types
2. **Variable declarations** - Declare types for meta-variables
3. **Relation declarations** - Define judgment forms
4. **Rule definitions** - Express inference rules
5. **Function definitions** - Define meta-level computations
6. **Grammar definitions** - Specify concrete syntax

### Meta-Level vs Object-Level

- **Object-level** - The language being specified (e.g., WebAssembly)
- **Meta-level** - The specification language itself (SpecTec)

SpecTec notation exists at the meta-level to describe object-level constructs.

---

## Language Reference

### Comments

```
;; Line comment

(; Block comment ;)
```

### Identifiers

**Variables** (lowercase start):
```
x, foo, myVar_1, t'
```

**Atoms** (uppercase start):
```
NOP, DROP, I32, CONST
```

**Escaped identifiers** (flip case):
```
`C, `_name, `DROP
```

**Functions** (start with $):
```
$size, $local, $f_1
```

### Literals

**Numbers:**
```
42          ;; Natural number
0xFF        ;; Hexadecimal
-5          ;; Integer
`123        ;; Number rendered as atom
```

**Booleans:**
```
true
false
```

**Text:**
```
"hello world"
```

### Operators

**Logical:**
```
~           ;; not
/\          ;; and
\/          ;; or
=>          ;; implies
```

**Comparison:**
```
=           ;; equal
=/=         ;; not equal
<, >, <=, >=
```

**Arithmetic** (inside `$(...)` escape):
```
+, -, *, /, \, ^
```

### Symbolic Atoms

Common symbolic atoms used in notation:

```
:           ;; colon
;           ;; semicolon
->          ;; arrow (function type)
=>          ;; arrow (production)
~>          ;; reduction arrow
|-          ;; turnstile
..          ;; range
...         ;; ellipsis
?           ;; optional (escaped: `?)
*           ;; star/list (escaped: `*)
+           ;; plus (escaped: `+)
```

---

## Type System

### Primitive Types

```
bool        ;; Boolean values
nat         ;; Natural numbers (0, 1, 2, ...)
int         ;; Integers (..., -1, 0, 1, ...)
rat         ;; Rational numbers
real        ;; Real numbers
text        ;; Text strings
```

### Type Expressions

**Tuples:**
```
(nat, bool)          ;; Pair of nat and bool
(nat, nat, text)     ;; Triple
```

**Iterations:**
```
nat*                 ;; List of nat
nat?                 ;; Optional nat
valtype*             ;; List of valtypes
```

**Named types:**
```
instr                ;; User-defined type
matrix(nat)          ;; Parameterized type
```

### Syntax Definitions

#### Type Aliases

```spectec
syntax idx = nat
syntax localidx = nat
syntax globalidx = nat
```

#### Variant Types

Define alternatives separated by `|`:

```spectec
syntax valtype = I32 | I64 | F32 | F64

syntax numtype = I32 | I64 | F32 | F64

syntax instr =
  | NOP
  | DROP
  | SELECT
  | CONST valtype nat
  | LOCAL.GET localidx
  | BLOCK instr*
```

Each case must start with a unique atom to be distinguishable.

#### Record Types

Define structures with named fields:

```spectec
syntax context = {
  GLOBALS globaltype*,
  LOCALS valtype*,
  LABELS (valtype*)*
}

syntax store = {
  FUNCS funcinst*,
  TABLES tableinst*,
  MEMS meminst*,
  GLOBALS globalinst*
}
```

Access fields with dot notation:
```spectec
C.LOCALS
s.GLOBALS
```

#### Range Types

Enumerate numeric values:

```spectec
syntax byte = 0x00 | ... | 0xFF

syntax int32 = -2^31 | ... | -1 | 0 | +1 | ... | +2^31-1
```

#### Constructor Types

Define custom notation with atoms:

```spectec
syntax functype = valtype* -> valtype*

syntax limits = `[nat .. nat]

syntax config = state; instr*
```

### Type Parameterization

Types can have parameters:

```spectec
syntax matrix(syntax x) = x**

syntax vec(N : nat) = byte^N

syntax tuple(nat)
syntax tuple(0) = ()
syntax tuple(1) = (nat)
syntax tuple(2) = (nat, nat)
```

### Premises on Types

Add side conditions to type definitions:

```spectec
syntax int32 = int  -- if int >= $(-2^31) /\ int < $(+2^31)
```

### Type Fragments

Split large type definitions:

```spectec
syntax instr/stack = DROP | ...

syntax instr/arith = ... | CONST numtype const | ...

syntax instr/control = ... | BR labelidx | BLOCK instr*
```

### Subtyping

SpecTec employs shallow structural subtyping:

- Variant types: Subset of cases creates subtype
- Record types: Superset of fields creates subtype
- Tuple types: Component-wise subtyping

Example:
```spectec
syntax inttype = I32 | I64
syntax floattype = F32 | F64
syntax numtype = inttype | floattype
```

Here `inttype` and `floattype` are subtypes of `numtype`.

---

## Expressions

### Variables

```spectec
x                    ;; Simple variable
t_1                  ;; Variable with subscript
C                    ;; Uppercase (requires declaration)
```

### Literals

```spectec
42                   ;; Natural number
true                 ;; Boolean
"text"               ;; String
```

### Tuples

```spectec
(x, y)               ;; Pair
(a, b, c)            ;; Triple
```

### Sequences and Lists

**Empty sequence:**
```spectec
eps
```

**Sequencing:**
```spectec
a b c                ;; Sequence of three elements
```

**List operations:**
```spectec
[a, b, c]            ;; Explicit list
l ++ m               ;; Concatenation
l[i]                 ;; Indexing (zero-based)
l[2 : 3]             ;; Slicing (offset 2, length 3)
|l|                  ;; Length
x <- l               ;; Membership
```

**List updates:**
```spectec
l[[2] = x]           ;; Replace element at index 2
l[[2] =++ x y]       ;; Append to element at index 2
```

### Records

**Formation:**
```spectec
{GLOBALS gt*, LOCALS lt*}
```

**Access:**
```spectec
C.LOCALS             ;; Field access
C.LOCALS[x]          ;; Indexed field access
```

**Composition:**
```spectec
r1 ++ r2             ;; Merge records
```

**Extension:**
```spectec
C, LABEL t*          ;; Short for C ++ {LABEL t*}
```

**Updates:**
```spectec
C[.LOCALS[x] = t]    ;; Update nested field
```

### Arithmetic Expressions

Must be enclosed in `$(...)`:

```spectec
$(n + 1)
$(2^7 * m + (n - 2^7))
$(|x| * 2)
```

### Boolean Expressions

```spectec
x = y
x =/= y
x < y
x >= y
condition_1 /\ condition_2
condition_1 \/ condition_2
~condition
```

### Function Calls

```spectec
$f(x, y)             ;; Function application
$const               ;; Constant (no args)
$size(I32)           ;; Function with one arg
```

### Custom Notation

Use atoms and operators as defined in types:

```spectec
t_1* -> t_2*         ;; Function type
s; f                 ;; State pair
C |- instr : ft      ;; Typing judgment
```

### Iteration Expressions

Apply iteration to expressions:

```spectec
x*                   ;; List of x values
{A x, B 1}*          ;; List of records
$f(x, i)^(i<n)       ;; Indexed iteration
```

---

## Functions

### Function Declarations

Declare type before defining:

```spectec
def $size(valtype) : nat

def $local(state, localidx) : val

def $map(syntax X, def $f(X) : X, X*) : X*
```

### Function Clauses

Define with pattern matching:

```spectec
def $size(I32) = 32
def $size(I64) = 64
def $size(F32) = 32
def $size(F64) = 64
```

### Pattern Matching in Functions

```spectec
def $local((s; f), x) = f.LOCALS[x]

def $find(n, eps) = false
def $find(n, n n'*) = true           ;; Non-linear pattern
def $find(n, n_1 n'*) = $find(n, n'*)
```

### Premises in Functions

Add conditions with `--`:

```spectec
def $abs(int) : nat
def $abs(+n) = n      -- if n >= 0
def $abs(-n) = n      -- if n < 0
```

Or use `otherwise`:

```spectec
def $f(nat) : nat
def $f(0) = 0
def $f(n) = 1         -- otherwise
```

### Recursive Functions

Functions can be recursive:

```spectec
def $factorial(nat) : nat
def $factorial(0) = 1
def $factorial(n) = $(n * $factorial($(n - 1)))
```

### Mutually Recursive Functions

Separate declaration from definition:

```spectec
def $tik(nat) : bool
def $tok(nat) : bool

def $tik(0) = false
def $tik(n) = $tok($(n - 1))

def $tok(0) = true
def $tok(n) = $tik($(n - 1))
```

### Higher-Order Functions

Functions can take other functions as parameters:

```spectec
def $map(syntax X, def $f(X) : X, X*) : X*
def $map(syntax X, $f, eps) = eps
def $map(syntax X, $f, x y*) = $f(x) $map(X, $f, y*)
```

### Polymorphic Functions

Use `syntax` parameters:

```spectec
def $len(syntax X, X*) : nat
def $len(syntax X, eps) = 0
def $len(syntax X, x x'*) = $(1 + $len(X, x'*))
```

---

## Relations and Rules

### Relation Declarations

Define judgment forms:

```spectec
relation Instr_ok: context |- instr : functype

relation Step: config ~> config

relation Matches: val MATCHES reftype
```

### Rule Definitions

Define inference rules:

```spectec
rule Instr_ok/nop:
  C |- NOP : eps -> eps

rule Instr_ok/drop:
  C |- DROP : t -> eps

rule Instr_ok/select:
  C |- SELECT : t t I32 -> t
```

### Rules with Premises

**Boolean conditions:**
```spectec
rule Instr_ok/local.get:
  C |- LOCAL.GET x : eps -> t
  -- if C.LOCALS[x] = t
```

**Relational premises:**
```spectec
rule Instr_ok/block:
  C |- BLOCK instr* : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr* : t_1* -> t_2*
```

**Iterated premises:**
```spectec
rule Module_ok:
  |- module : t_1* -> t_2*
  -- (Func_ok: C |- func : ft)*
  -- (Table_ok: C |- table : tt)*
```

### Rule Naming

Rules are named hierarchically:

```spectec
rule Step/if-true:
  z; (I32.CONST c) (IF instr_1* ELSE instr_2*) ~> z; (BLOCK instr_1*)
  -- if c =/= 0

rule Step/if-false:
  z; (I32.CONST c) (IF instr_1* ELSE instr_2*) ~> z; (BLOCK instr_2*)
  -- otherwise
```

### Otherwise Conditions

Use `otherwise` to negate previous conditions:

```spectec
rule Step_pure/select-true:
  val_1 val_2 (CONST I32 c) SELECT ~> val_1
  -- if c =/= 0

rule Step_pure/select-false:
  val_1 val_2 (CONST I32 c) SELECT ~> val_2
  -- otherwise
```

---

## Grammars and Attribute Grammars

### Grammar Definitions

Define concrete syntax:

```spectec
grammar Bvaltype : valtype =
  | 0x7F => I32
  | 0x7E => I64
  | 0x7D => F32
  | 0x7C => F64
```

### Attribute Patterns

Bind synthesized attributes:

```spectec
grammar Bresulttype : valtype* =
  | n:Bu32 (t:Bvaltype)^n => t^n
```

### Parameterized Grammars

```spectec
grammar Bu(N : nat) : nat =
  | n:Bbyte              => n
      -- if $(n < 2^7 /\ n < 2^N)
  | n:Bbyte m:Bu($(N-7)) => $(2^7 * m + (n - 2^7))
      -- if $(n >= 2^7 /\ N > 7)

grammar Bu32 : nat = n:Bu(32) => n
grammar Bu64 : nat = n:Bu(64) => n
```

### Grammar Symbols

**Terminals:**
```spectec
0x60                 ;; Hex byte
"block"              ;; Text literal
```

**Non-terminals:**
```spectec
Bvaltype             ;; Grammar reference
```

**Iterations:**
```spectec
(t:Bvaltype)*        ;; Zero or more
(t:Bvaltype)+        ;; One or more
(t:Bvaltype)?        ;; Optional
```

**Alternatives:**
```spectec
Binstr | Bdata       ;; Alternative
```

**Ranges:**
```spectec
0x00 | ... | 0xFF    ;; Numeric range
```

### Synthesized Attributes

Grammars compute values from parsed syntax:

```spectec
grammar Bfunctype : functype =
  | 0x60 t_1*:Bresulttype t_2*:Bresulttype => t_1* -> t_2*
```

---

## Pattern Matching

### Basic Patterns

**Variables:**
```spectec
def $f(n) = ...      ;; Bind n
```

**Literals:**
```spectec
def $f(0) = ...      ;; Match zero
def $f(42) = ...     ;; Match 42
```

**Atoms:**
```spectec
def $f(I32) = ...    ;; Match I32
```

### Structured Patterns

**Tuples:**
```spectec
def $first((x, y)) = x
```

**Records:**
```spectec
def $get_locals({LOCALS l*, ...}) = l*
```

**Variants:**
```spectec
def $is_nop(NOP) = true
def $is_nop(DROP) = false
```

### Non-Linear Patterns

Use same variable multiple times:

```spectec
def $find(n, n n'*) = true    ;; n appears twice
```

### Iteration Patterns

Match sequences:

```spectec
def $len(i^n) = n             ;; Bind length

def $unzip((x, y)*) = x*, y*  ;; Match and destructure
```

### Signed Patterns

Match by sign:

```spectec
def $abs(+n) = n              ;; Match positive
def $abs(-n) = n              ;; Match negative
```

### Wildcard Patterns

Ignore values:

```spectec
def $ignore(_, x) = x
```

---

## Iterations and Sequences

### Iteration Syntax

**Optional:**
```spectec
MUT?                 ;; 0 or 1 element
```

**List:**
```spectec
valtype*             ;; 0 or more elements
```

**Non-empty list:**
```spectec
valtype+             ;; 1 or more elements (expressions only)
```

**Fixed length:**
```spectec
byte^4               ;; Exactly 4 elements (expressions only)
```

**Indexed iteration:**
```spectec
$f(x, i)^(i<n)       ;; With index variable (expressions only)
```

### Dimension Vectors

Variables can have multiple dimensions:

```spectec
x*                   ;; One-dimensional list
x**                  ;; Two-dimensional list
(x^3)*               ;; List of triples
```

### Parallel Iteration

Iterate over multiple variables:

```spectec
{A x, B y}*          ;; x and y iterated in parallel
```

All iterated variables must have same dimension.

### Nested Iteration

```spectec
z**                  ;; Nested lists
(y^n)*               ;; List of fixed-size sequences
```

### Iteration in Patterns

```spectec
def $sum(eps) = 0
def $sum(n n'*) = $(n + $sum(n'*))
```

### Iteration Type Inference

SpecTec infers dimensions from usage:

```spectec
;; Infers: x**, y*, scalar z and l
l = {A x, B y, C z}** /\ (x < 100)** /\ z <- y*
```

---

## Splicing and Document Generation

### Splice Syntax

**Expression splices:**
```
${typ: exp}          ;; Inline math
```

**Definition splices:**
```
$${sort: name*}      ;; Block definitions
```

### Splice Tags

**For Sphinx (reStructuredText):**
- `$` - Inline math (`:math:`)
- `$$` - Block math (`.. math::`)

**For LaTeX:**
- `#` - Inline math (`$...$`)
- `##` - Block math (`$$...$$`)

### Definition Sorts

**Syntax:**
```
$${syntax: valtype functype instr}
```

**Rules:**
```
$${rule: Instr_ok/nop Instr_ok/drop}
```

**Rule prose:**
```
$${rule-prose: Instr_ok/nop}
```

**Relations:**
```
$${relation: Instr_ok Step}
```

**Functions:**
```
$${definition: $size $local}
```

**Function prose:**
```
$${definition-prose: $size}
```

**Grammars:**
```
$${grammar: Bvaltype Binstr}
```

### Grouping Definitions

**Align together:**
```
$${rule: Instr_ok/nop Instr_ok/drop Instr_ok/select}
```

**Group without spacing:**
```
$${rule: {Instr_ok/nop Instr_ok/drop}}
```

### Wildcards in Names

```
$${rule: Instr_ok/*}         ;; All Instr_ok rules
$${rule: Step/if-*}          ;; All Step/if-* rules
```

### Decorated Splices

**With descriptions:**
```
$${syntax+: valtype}         ;; Include desc hint
```

**With names:**
```
$${rule+: Instr_ok/nop}      ;; Include rule name
```

### Ignore Splices

```
$${rule-ignore: Internal/rule}
```

### Example Document

```rst
Types
=====

Value types are as follows:

$${syntax: valtype}

Validation
==========

The NOP instruction does nothing:

$${rule-prose: Instr_ok/nop}

Formally:

$${rule: Instr_ok/nop}
```

---

## Backends

### LaTeX Backend

Generates formal mathematical notation:

```bash
$ spectec spec.spectec --splice-sphinx -p input.rst.in -o output.rst
```

**Features:**
- Inference rules
- Tabular rules (with `hint(tabular)`)
- Custom macros (with `--latex-macros`)
- Aligned definitions

### Prose Backend

Generates English algorithmic descriptions:

```bash
$ spectec spec.spectec --prose
$ spectec spec.spectec --prose-rst
```

**Generates:**
- Validation prose (declarative)
- Execution prose (algorithmic)
- Function definitions (algorithmic)

**Example output:**
```
Instr_ok/local.get
- The instruction `LOCAL.GET x` is valid with type `[] -> [t]` if:
  - The local type `C.LOCALS[x]` exists.
  - `C.LOCALS[x]` is `SET t`.
```

### Interpreter Backend

Executes WebAssembly programs using the specification:

```bash
$ spectec spec/*.spectec --interpreter test.wasm
$ spectec spec/*.spectec --interpreter test.wast
```

**Features:**
- Direct interpretation of formal specification
- Module instantiation
- Function invocation
- Test suite execution

**Limitations:**
- Specific to WebAssembly
- Relies on reference interpreter for parsing and numerics

---

## Hints and Customization

### Show Hints

Control rendering appearance:

```spectec
syntax instr = 
  | CONST valtype nat  hint(show %.CONST %)
  | EXTEND numtype n   hint(show %.EXTEND#%)

def $size(valtype) : nat  hint(show |%|)
```

**Holes:**
- `%` - Next argument
- `%i` - i-th argument
- `%%` - Remaining arguments
- `%0` - Name of entity
- `!%` - Empty space
- `%latex("text")` - Literal LaTeX

**Operators:**
- `exp#exp` - Concatenate (remove space)
- `##exp` - Remove parentheses

### Description Hints

Add descriptions for types:

```spectec
syntax valtype hint(desc "value type") =
  | numtype
  | vectype
  | reftype
```

Used in prose generation and decorated splices.

### Name Hints

Control rule name rendering:

```spectec
relation Instr_ok: context |- instr : functype
  hint(name "T")

rule Instr_ok/drop: C |- DROP : t -> eps
```

Renders as `[T-drop]`.

### Macro Hints

Control macro names:

```spectec
syntax comptype hint(macro "%" "T%") =
  | STRUCT structtype
  | ARRAY arraytype
  | FUNC functype
```

Generates: `\comptype`, `\TSTRUCT`, `\TARRAY`, `\TFUNC`.

### Tabular Hint

Render rules as clauses:

```spectec
relation Step hint(tabular)
```

### Prose Hints

Customize prose generation:

```spectec
relation Expand: deftype ~~ comptype
  hint(prose "The expansion of" %1 "is" %2)
```

---

## Advanced Features

### Dependent Types

Types can depend on values:

```spectec
syntax vec(N : nat) = byte^N
```

### Type Families

Define types with case-based definitions:

```spectec
syntax tuple(nat)
syntax tuple(0) = ()
syntax tuple(1) = (nat)
syntax tuple(2) = (nat, nat)
```

### Parameterized Relations

```spectec
relation Valid(version : nat): context |- module
```

### Alternate Signs

Express dual cases:

```spectec
def $f(int, int) : int
def $f(+-n, +-m) = $(+-n*2 + +-m)   ;; Same sign
def $f(+-n, -+m) = $(-+n*3 + +-m)   ;; Opposite signs
```

### Numeric Conversions

```spectec
$nat$(x)             ;; Convert to nat
$int$(x)             ;; Convert to int
```

### Path Updates

Update nested structures:

```spectec
C[.LOCALS[x] = t]                    ;; Update in record
l[[2][0] = x]                        ;; Update in nested list
```

### Recursion Groups

SpecTec infers recursion groups automatically.

---

## Best Practices

### Naming Conventions

- **Variables:** lowercase (`x`, `t`, `n`)
- **Atoms:** uppercase (`NOP`, `I32`)
- **Functions:** start with `$` (`$size`, `$local`)
- **Types:** lowercase (`valtype`, `instr`)

### Type Declarations

Declare types for uppercase variables:

```spectec
var C : context
var S : store
```

### Function Organization

1. Declare types first
2. Define clauses later
3. Group related functions

```spectec
;; Declarations
def $size(valtype) : nat
def $pack(valtype) : packtype

;; Definitions
def $size(I32) = 32
def $size(I64) = 64

def $pack(I32) = I8
def $pack(I64) = I16
```

### Rule Organization

Use descriptive hierarchical names:

```spectec
rule Instr_ok/control/block: ...
rule Instr_ok/control/loop: ...
rule Instr_ok/control/if: ...
```

### Iteration Usage

Prefer iteration over explicit recursion:

```spectec
;; Good
{A x, B 1}*

;; Less good
def $make_list(nat*) : record*
def $make_list(eps) = eps
def $make_list(n n'*) = {A n, B 1} $make_list(n'*)
```

### Documentation

Use comments liberally:

```spectec
;; Type for representing function types
syntax functype = valtype* -> valtype*

;; Check if value matches reference type
relation Matches: val MATCHES reftype
```

---

## Examples and Tutorials

### Example 1: Simple Type System

```spectec
;; Define types
syntax typ = NAT | BOOL

;; Define expressions
syntax exp =
  | NUM nat
  | TRUE
  | FALSE
  | ADD exp exp
  | IF exp exp exp

;; Define typing relation
relation Type: exp : typ

rule Type/num:
  NUM n : NAT

rule Type/true:
  TRUE : BOOL

rule Type/false:
  FALSE : BOOL

rule Type/add:
  ADD e_1 e_2 : NAT
  -- Type: e_1 : NAT
  -- Type: e_2 : NAT

rule Type/if:
  IF e_1 e_2 e_3 : t
  -- Type: e_1 : BOOL
  -- Type: e_2 : t
  -- Type: e_3 : t
```

### Example 2: Stack Machine

```spectec
;; Values
syntax val = INT int

;; Instructions
syntax instr =
  | PUSH int
  | ADD
  | MUL

;; Configuration
syntax config = val*; instr*

;; Reduction
relation Step: config ~> config hint(tabular)

rule Step/push:
  s; (PUSH i) is* ~> (INT i) s; is*

rule Step/add:
  (INT i_1) (INT i_2) s; ADD is* ~> (INT $(i_1 + i_2)) s; is*

rule Step/mul:
  (INT i_1) (INT i_2) s; MUL is* ~> (INT $(i_1 * i_2)) s; is*
```

### Example 3: Binary Format

```spectec
;; Abstract syntax
syntax valtype = I32 | I64 | F32 | F64

;; Binary grammar
grammar Bbyte : nat = b:0x00 | ... | b:0xFF => b

grammar Bvaltype : valtype =
  | 0x7F => I32
  | 0x7E => I64
  | 0x7D => F32
  | 0x7C => F64

grammar Bu32 : nat =
  | n:Bbyte              => n           -- if $(n < 128)
  | n:Bbyte m:Bu32       => $(128*m + (n-128))
                                         -- if $(n >= 128)

grammar Bresulttype : valtype* =
  | n:Bu32 (t:Bvaltype)^n => t^n

grammar Bfunctype : functype =
  | 0x60 t_1*:Bresulttype t_2*:Bresulttype => t_1* -> t_2*
```

### Example 4: Function with Pattern Matching

```spectec
;; Type for lists
syntax list = NIL | CONS nat list

;; Length function
def $length(list) : nat
def $length(NIL) = 0
def $length(CONS n l) = $(1 + $length(l))

;; Append function
def $append(list, list) : list
def $append(NIL, l) = l
def $append(CONS n l_1, l_2) = CONS n $append(l_1, l_2)

;; Map function (higher-order)
def $map(def $f(nat) : nat, list) : list
def $map($f, NIL) = NIL
def $map($f, CONS n l) = CONS $f(n) $map($f, l)
```

---

## Troubleshooting

### Type Inference Failures

**Problem:** SpecTec cannot infer types.

**Solution:** Add variable declarations:
```spectec
var x : nat
var t : valtype
```

### Ambiguous Notation

**Problem:** Custom notation is ambiguous.

**Solution:** Ensure context provides type information or use explicit type annotations.

### Recursion Issues

**Problem:** Type checking doesn't terminate.

**Solution:** Avoid recursive type aliases. Use nominal recursion through variant types.

### Pattern Matching Failures

**Problem:** Patterns don't match as expected.

**Solution:** Remember patterns are compared after reduction to normal form.

### Dimension Mismatches

**Problem:** Iteration dimensions don't match.

**Solution:** Check that all iterated variables in parallel have the same dimension.

### Missing Definitions

**Problem:** Undefined function or type.

**Solution:** Ensure declarations come before uses.

---

## Internal Representations

### External Language (EL)

The input language as written by users.

### Internal Language (IL)

After type-checking, SpecTec elaborates to IL:

- Explicit type annotations
- Local variable binders
- Recursion groups
- Dependency order
- Subtype injections

View IL in AST mode:

```bash
$ spectec spec.spectec --ast -o spec.il
```

### Algorithmic Language (AL)

For prose and interpreter backends, IL is further translated to AL:

- Algorithmic representation
- Step-by-step execution
- Variable bindings explicit
- Control flow explicit

### S-Expression Format

IL can be output in machine-readable S-expressions:

```lisp
(def "size" ((exp "nt" (var "valtype"))) (nat)
  ((clause () ((case "%I32%" ())) ((num (nat 32))) ())
   (clause () ((case "%I64%" ())) ((num (nat 64))) ())))
```

---

## Command-Line Reference

### Basic Commands

**Check specification:**
```bash
$ spectec file.spectec
```

**Multiple files:**
```bash
$ spectec file1.spectec file2.spectec file3.spectec
```

**AST output:**
```bash
$ spectec file.spectec --ast -o output.il
```

### Splicing Commands

**Sphinx splicing:**
```bash
$ spectec spec.spectec --splice-sphinx -p input.rst.in -o output.rst
```

**LaTeX splicing:**
```bash
$ spectec spec.spectec --splice-latex -p input.tex.in -o output.tex
```

**In-place splicing:**
```bash
$ spectec spec.spectec --splice-sphinx -p file.rst.in -i
```

**Multiple files:**
```bash
$ spectec spec.spectec --splice-sphinx -p in1.rst in2.rst -o out1.rst out2.rst
```

### Prose Generation

**Plain text:**
```bash
$ spectec spec.spectec --prose
```

**reStructuredText:**
```bash
$ spectec spec.spectec --prose-rst
```

### Interpreter

**Run wasm file:**
```bash
$ spectec spec/*.spectec --interpreter test.wasm
```

**Run wast script:**
```bash
$ spectec spec/*.spectec --interpreter test.wast
```

**Run test directory:**
```bash
$ spectec spec/*.spectec --interpreter test-dir/
```

### Options

**Logging:**
```bash
$ spectec -l file.spectec              # Log processing
$ spectec -ll file.spectec --interpreter test.wast    # Log execution
```

**Warnings:**
```bash
$ spectec spec.spectec --splice-sphinx -p in.rst -o out.rst -w
$ spectec spec.spectec --splice-sphinx -p in.rst -o out.rst --warn-math
$ spectec spec.spectec --splice-sphinx -p in.rst -o out.rst --warn-prose
```

**Macros:**
```bash
$ spectec spec.spectec --splice-sphinx -p in.rst -o out.rst --latex-macros
```

**Dry run:**
```bash
$ spectec spec.spectec --splice-sphinx -p in.rst -d
```

**Version:**
```bash
$ spectec -v
```

**Help:**
```bash
$ spectec --help
```

---

## Conclusion

SpecTec is a powerful tool for writing formal specifications. Its combination of:

- **Readable notation** - Close to pen-and-paper style
- **Type checking** - Catches errors early
- **Multiple backends** - Generate various artifacts
- **Extensibility** - Hints allow customization

makes it ideal for collaborative specification work. While it was designed for WebAssembly, its generic mechanisms (syntax types, relations, functions, grammars) make it applicable to other formal language specifications as well.

The key to effective use of SpecTec is understanding:

1. The distinction between meta-level and object-level
2. How types guide notation and checking
3. How pattern matching and iteration work
4. How backends interpret the specification

With these concepts mastered, SpecTec becomes a natural and efficient way to write precise, maintainable formal specifications.

---

## Additional Resources

- [SpecTec GitHub Repository](https://github.com/WebAssembly/spec/tree/main/spectec)
- [WebAssembly Specification](https://webassembly.github.io/spec/)
- [Example Directory](https://github.com/WebAssembly/spec/tree/main/spectec/doc/example)
- [Test Files](https://github.com/WebAssembly/spec/tree/main/spectec/spec)

---

**Last Updated:** 2025-11-01

**SpecTec Version:** Latest (as of main branch)

**Document Status:** Comprehensive reference based on official documentation
